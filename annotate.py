import sys
import argparse
from pathlib import Path
import math
import json

from mcap.mcap0.reader import make_reader
from mcap.mcap0.writer import Writer

import events

EVENT_SCHEMA = {
  "title": "foxglove.Event",
  "description": "a message used to annotate some event of interest in the data",
  "$comment": "Generated by https://github.com/foxglove/schemas",
  "type": "object",
  "properties": {
    "timestamp": {
      "type": "object",
      "title": "time",
      "properties": {
        "sec": {
          "type": "integer",
          "minimum": 0
        },
        "nsec": {
          "type": "integer",
          "minimum": 0,
          "maximum": 999999999
        }
      },
      "description": "time when the event occurred"
    },
    "duration": {
      "type": "object",
      "title": "duration",
      "properties": {
        "sec": {
          "type": "integer"
        },
        "nsec": {
          "type": "integer",
          "minimum": 0,
          "maximum": 999999999
        }
      },
      "description": "duration of event, starting at `timestamp`"
    },
    "metadata": {
      "type": "array",
      "items": {
        "title": "foxglove.EventKeyValue",
        "description": "a single key-value pair of metadata for an event",
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "key for this metadata"
          },
          "value": {
            "type": "string",
            "description": "value of the metadata"
          }
        }
      },
      "description": "array of key-value metadata for this event"
    }
  }
}

def add_event_channel(writer):
    schema_id = writer.register_schema(name="foxglove.Event", encoding="jsonschema", data=json.dumps(EVENT_SCHEMA).encode("utf-8"))
    return writer.register_channel(topic="/events", message_encoding="json", schema_id=schema_id)


def add_event(writer, channel_id, event: events.Event):
    timestamp_sec, timestamp_nsec = divmod(event.timestamp_ns, 1_000_000_000)
    duration_sec, duration_nsec = divmod(event.duration_ns, 1_000_000_000)
    writer.add_message(
        channel_id=channel_id,
        log_time=event.timestamp_ns,
        publish_time=event.timestamp_ns,
        data=json.dumps({
            "timestamp": {"sec": timestamp_sec, "nsec": timestamp_nsec},
            "duration": {"sec": duration_sec, "nsec": duration_nsec},
            "metadata": [
                {"key": key, "value": value}
                for key, value in event.metadata.items()
            ],
        }).encode("utf-8")
    )


def annotate(infile, outfile):
    reader = make_reader(infile)
    writer = Writer(outfile)
    writer.start()
    channel_id = add_event_channel(writer)
    summary = reader.get_summary()
    topics = ["/markers/annotations", "/imu"]
    if not topics:
        raise RuntimeError("found no topics to annotate, is this a NuScenes MCAP?")

    annotator = events.Annotator()
    scene_info = next(
        (metadata for metadata in reader.iter_metadata() if metadata.name == "scene-info"),
        None
    )
    for event in annotator.on_mcap_start(summary, scene_info):
        add_event(writer, channel_id, event)

    for schema, _, message in reader.iter_messages(topics=topics):
        if schema.name == "sensor_msgs/Imu":
            imu = Imu()
            imu.deserialize(message.data)
            for event in annotator.on_imu(imu):
                add_event(writer, channel_id, event)
        if schema.name == "visualization_msgs/MarkerArray":
            marker_array = MarkerArray()
            marker_array.deserialize(message.data)
            for event in annotator.on_marker_array(marker_array):
                add_event(writer, channel_id, event)
    
    for event in annotator.on_mcap_end():
        add_event(writer, channel_id, event)
    writer.finish()

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("input", type=Path, help="input MCAP to annotate")
    parser.add_argument("--output", "-o", type=Path, help="path to write MCAP file with annotations")

    args = parser.parse_args()

    if not args.input.is_file():
        print("Input is not a file", file=sys.stderr)
        return 1

    if not args.output:
        args.output = args.input.resolve().parent / (args.input.stem + "-annotations.mcap")

    args.output.parent.mkdir(parents=True, exist_ok=True)

    with open(args.input, "rb") as infile, open(args.output, "wb") as outfile:
        annotate(infile, outfile)

    return 0

if __name__ == "__main__":
    sys.exit(main())
