import sys
import argparse
from pathlib import Path
import math
import json

from sensor_msgs.msg import Imu
from visualization_msgs.msg import MarkerArray
from rospy import Time

from mcap.mcap0.reader import make_reader
from mcap.mcap0.writer import Writer

SCHEMAS_OF_INTEREST = set([
    "sensor_msgs/Imu",
    "visualization_msgs/MarkerArray",
])

EVENT_SCHEMA = {
  "title": "foxglove.Event",
  "description": "a message used to annotate some event of interest in the data",
  "$comment": "Generated by https://github.com/foxglove/schemas",
  "type": "object",
  "properties": {
    "timestamp": {
      "type": "object",
      "title": "time",
      "properties": {
        "sec": {
          "type": "integer",
          "minimum": 0
        },
        "nsec": {
          "type": "integer",
          "minimum": 0,
          "maximum": 999999999
        }
      },
      "description": "time when the event occurred"
    },
    "duration": {
      "type": "object",
      "title": "duration",
      "properties": {
        "sec": {
          "type": "integer"
        },
        "nsec": {
          "type": "integer",
          "minimum": 0,
          "maximum": 999999999
        }
      },
      "description": "duration of event, starting at `timestamp`"
    },
    "metadata": {
      "type": "array",
      "items": {
        "title": "foxglove.EventKeyValue",
        "description": "a single key-value pair of metadata for an event",
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "key for this metadata"
          },
          "value": {
            "type": "string",
            "description": "value of the metadata"
          }
        }
      },
      "description": "array of key-value metadata for this event"
    }
  }
}

ACCELERATION_THRESHOLD = 1.5
PEDESTRIAN_THRESHOLD = 20

def add_event_channel(writer):
    schema_id = writer.register_schema(name="foxglove.Event", encoding="jsonschema", data=json.dumps(EVENT_SCHEMA).encode("utf-8"))
    return writer.register_channel(topic="/events", message_encoding="json", schema_id=schema_id)


def add_event(writer, channel_id, start_time, end_time, metadata):
    if end_time < start_time:
        raise RuntimeError("event has negative duration")
    duration = end_time - start_time
    writer.add_message(
        channel_id=channel_id,
        log_time=to_ns(end_time),
        publish_time=to_ns(end_time),
        data=json.dumps({
            "timestamp": {"sec": start_time.secs, "nsec": start_time.nsecs},
            "duration": {"sec": duration.secs, "nsec": duration.nsecs},
            "metadata": [
                {"key": key, "value": value}
                for key, value in metadata.items()
            ],
        }).encode("utf-8")
    )


def get_topics_of_interest(summary):
    schema_ids = set(
        schema_id
        for schema_id, schema in summary.schemas.items()
        if schema.name in SCHEMAS_OF_INTEREST
    )
    return [
        channel.topic
        for channel in summary.channels.values()
        if channel.schema_id in schema_ids
    ]

def to_ns(rospy_time):
    return rospy_time.nsecs + (1_000_000_000 * rospy_time.secs)


def last_timestamp(summary):
    end_time = summary.statistics.message_end_time
    secs, nsecs = divmod(end_time, 1_000_000_000)
    return Time(secs=secs, nsecs=nsecs)


def annotate(infile, outfile):
    reader = make_reader(infile)
    writer = Writer(outfile)
    writer.start()
    channel_id = add_event_channel(writer)
    summary = reader.get_summary()
    topics = get_topics_of_interest(summary)
    if not topics:
        raise RuntimeError("found no topics to annotate, is this a NuScenes MCAP?")

    jerk_start_time = None
    max_acceleration = 0.0

    ped_event_start_time = None
    max_num_peds = 0

    for schema, channel, message in reader.iter_messages(topics=topics):
        if schema.name == "sensor_msgs/Imu":
            imu = Imu()
            imu.deserialize(message.data)
            longitudinal_acceleration = abs(imu.linear_acceleration.x)
            if longitudinal_acceleration >= ACCELERATION_THRESHOLD:
                if jerk_start_time is None:
                    jerk_start_time = imu.header.stamp
                max_acceleration = max(longitudinal_acceleration, max_acceleration)
            if longitudinal_acceleration < ACCELERATION_THRESHOLD and jerk_start_time is not None:
                add_event(writer, channel_id, jerk_start_time, imu.header.stamp, {
                    "large_acceleration": str(max_acceleration),
                })
                jerk_start_time = None
                max_acceleration = 0
        if schema.name == "visualization_msgs/MarkerArray":
            marker_array = MarkerArray()
            marker_array.deserialize(message.data)
            ped_count = sum(1 for marker in marker_array.markers if marker.text.startswith("pedestrian"))
            
            if ped_count > PEDESTRIAN_THRESHOLD:
                if ped_event_start_time is None:
                    ped_event_start_time = marker_array.header.stamp
                num_peds = sum(1 for marker in marker_array.markers if marker.ns.startswith("pedestrian"))
                max_num_peds = max(max_num_peds, num_peds)
            if ped_count < PEDESTRIAN_THRESHOLD and ped_event_start_time is not None:
                add_event(writer, channel_id, ped_event_start_time, marker_array.header.stamp, {
                    "many_pedestrians": str(max_num_peds),
                })

    if jerk_start_time is not None:
        add_event(writer, channel_id, jerk_start_time, last_timestamp(summary), {
            "large_acceleration": str(max_acceleration)
        })

    if ped_event_start_time is not None:
        add_event(writer, channel_id, ped_event_start_time, last_timestamp(summary), {
            "many_pedestrians": str(max_num_peds)
        })

    writer.finish()

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("input", type=Path, help="input MCAP to annotate")
    parser.add_argument("--output", "-o", type=Path, help="path to write MCAP file with annotations")

    args = parser.parse_args()

    if not args.input.is_file():
        print("Input is not a file", file=sys.stderr)
        return 1

    if not args.output:
        args.output = args.input.resolve().parent / (args.input.stem + "-annotations.mcap")

    args.output.parent.mkdir(parents=True, exist_ok=True)

    with open(args.input, "rb") as infile, open(args.output, "wb") as outfile:
        annotate(infile, outfile)

    return 0

if __name__ == "__main__":
    sys.exit(main())
